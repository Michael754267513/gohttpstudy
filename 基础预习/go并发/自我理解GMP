GMP
    G goroutine
    M 线程
    P processer 进程(根据runtime.GOMAXPROCS来限制并行执行的数量，默认是CPU的个数)



P 队列：(当本地队列满了就会存放到全局队列)
    全局G队列   当前P的队列，本地队列是Lock-Free，没有数据竞争问题，无需加锁处理，可以提升处理速度。
    本地G队列   全局队列为了保证多个P之间任务的平衡。所有M共享P全局队列，为保证数据竞争问题，需要加锁处理。相比本地队列处理速度要低于全局队列

P 列表（默认根据CPU个数，可以通过GOMAXPROCS来限制）


M 线程：(默认是10000个，也可以setmax threads设置)
    M绑定P,从P里面获取G，如本地队列获取不到G，则从全局队列P获取，或者从其他P 里面偷G 过来


P和M创建：
        P 确认多少后，运行时创建多少个P 根据操作系统CPU或者GOMAXPROCS来设置
        M 没有足够的M 关联P，时候会创建，还有G 在队列里面，P所在M阻塞，会使用空闲的M去执行G，没有空闲的M，就创建新的M去执行G
M清理：
    主动释放：
            系统设置超时时间，M出于block状态，超过了超时时间，M将会被P 释放掉，这时候P 就可以给其他的M 使用
    被动释放： 如果发生系统调用，有一个专门监控程序，进行扫描当前处于阻塞的P/M组合。当超过系统程序设置的超时时间，会自动将P资源抢走。去执行队列的其它G任务
抢占：
    在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方(防止一个goroutine一直占用CPU 导致其他goutine GG)

调度器：
       偷窃机制：
             当M没有可运行的G，会从其他P里面偷窃G 过来运行
        hand off：
               当M阻塞，线程释放绑定P，其他空闲的M就会绑定P，进行执行

上线文切换：
    当发生上线文切换的时候，把寄存器的值先保存起来，当后得到CPU去运行的时候，在恢复寄存器值(各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存(堆栈)信息等)

MO:
    启动程序会生成一个id 为0 的主线程，M0会在全局runtime.m0中，不需要分配heap，负责初始化和启动第一个G，后面的和M 一样
G0:
    M0 启动的时候，运行的第一个G，G0只负责G 的调度。每一个M都会有自己的G0，全局变量的G0是M0的G0