互斥锁：  在任何时刻只会有一个线程能访问到该对象


互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒

自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源


读写锁：rwlock，区分读和写，处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。
注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写优先于读，当有线程因为等待写锁而进入睡眠时，则后续读者也必须等待
适用于读取数据的频率远远大于写数据的频率的场合。
读写锁的访问控制规则如下：
①多个写操作之间是互斥的
②写操作与读操作之间也是互斥的
③多个读操作之间不是互斥的
在这样的控制规则下，读写锁可以大大降低性能损耗



RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高


信号量：semaphore，是用于线程间同步的，当一个线程完成操作后就通过信号量通知其它线程，然后别的线程就可以继续进行某些操作了。


信号量和互斥锁的区别：semaphore

    信号量是用于线程间同步的，而互斥锁是用于线程的互斥的
    互斥量的获取和释放都是在同一线程中完成的，pthread_mutex_lock(),pthread_mutex_unlock()。而信号量的获得和释放是在不同的线程的操作为sem_wait(),sempost()；
    互斥量的值只能为0和1，而信号量只要value>0，其它线程就可以sem_wait成功，成功后信号量value减一。若value值不大于0，则sem_wait阻塞，直到sem_post释放后value加1。因此信号量的值可以为非负整数
